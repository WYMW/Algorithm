## 归并排序

### 原理：

### 递归的合并N个已排序的子序列.

![avatar](http://blog.csgday.com/merge-sort1.png?e=1627128986&token=mKUKZX5Vt93oDz_rywI4Uas6jTVDNsv2s4U233LB:UzBVG57YlO6ufmzert49gkWkR1U=)

如上图所示，我们把单个的数字看成是一个已排序的子序列，然后不停的两两合并已排好序的子序列，直接全部合并完成。

## 流程

![avtar](http://blog.csgday.com/mergesort3.png)

1. 橙色部分为分解过程    2.黄色为合并过程   3. 绿色为执行顺序



###  从上面的流程图来看，这是一个标准的递归式解决方法。归并排序的每一层都包含三个步骤

1. 分解 :      将 n 个 元素 分割 成含有 n / 2个元素的子序列
2. 解决：    用归并排序法对两个子序列递归的排序
3. 合并：   合并两个已排序的子序列得到排序的结果

Merge-sort (array) {

​	merge-sort(left-arry)

   Merge-sort(right-arry)

   Merge(array)

}

我们可以把递归形象的理解成 [ 领导-员工 ] 任务模式。领导把任务分解成多个子任务然后派发给自己的多个直接下属， 然后下属再把子任务拆分派个自己的下属，下属的下属完成任务后把结果返回给下属，下属把结果处理后返回给领导，领导对返回的结果处理。

例如领导A要把  5 2 4 7 四个数字排序，

1.  他把这个任务分成两个子任务 【5， 2】 【4，7】 分别交给自己的下属 A-B, A-C。
2. A-B, A-C拿到任务后发现任务还可以接续分解， A-B 把自己的任务又分成  【5】【2】分配给 B-D 和 B-E。
3.  B-D和B-E拿到任务后发现自己的任务无法分解了， 自己进行处理 （单个数字的序列我们可以理解为已经排好序了). B-D 和 B-E ，把处理完的结果  【5】和 【2】返回给 A-B， A-B对结果进行处理得到 【2， 5】
4.  A-C 把自己的任务又分成  【4】【7】分配给 C-F 和 C-G。
5.  C-F和C-G拿到任务后发现自己的任务无法分解了， 自己进行处理 （单个数字的序列我们可以理解为已经排好序了). C-F 和 C-G ，把处理完的结果  【4】和 【7】返回给 A-C， A-C对结果进行处理得到 【4， 7】
6.  A-B和A-C把得到的结果 【2， 5】和 【4， 7】 返回给A， A对拿到的结果进行处理得到 【2， 4，5，7】



### 我们需要一个用来合并两个子序列的方法 merge

原理： 依次比较两个已排好序的子序列的每一个元素, 选择符合条件的一个放入对应的位置。

下面的过程每次都选择两个子序列中较小的那个元素放入相应的位置。

![avatar](http://blog.csgday.com/mergesort4.png)

```c
merge (array, start, mid, end) {
	 n1 = mid - start + 1
	 n2 = end - mid
   //创建两个数组 left, right, 长度分别为 n1 + 1, n2 + 1,然后把数组中对应位置的值复制到两个数组中。
   for i <- 0 < n1
     	do left[i] = array[start + i ]
   for j <-0 < n2
      do right[j] = array[mid + 1 + j]
  left [i + 1] = MAX_DOUBLE
  right [i + 1] = MAX_DOUBLE

  i = 0  j = 0
  for k <- start to end
    do if left[i] <= right[i]
      then array[k] <- left[i]
      i++
      else arry[h] <- right [i]
      j++
}
```

解惑： 为什么要在队尾加个 ∞ ？

这只是为了实现算法采用的一种方式。没有这个也完全可以。它的作用就是用来防止两个子序列的游标 i 和 j 越界。如上面代码所示，当一个子序列的元素全部被取完后，它的游标会指向正无穷大，意味着这个序列没有元素了，所以接下来的每一次比较他都是大的那个，这样就会把另一个数组剩余的元素放到指定的位置。如果是数组从大到小的排序，这个值就需要是负无穷大了。

如果没有这个标志，我们只需要用数组的长度和游标的位置来判断。如果游标的位置等于了长度，我们就不用比较了，把剩的数组的元素依次放到对应的位置就可以了。

### 合并排序的任务已经解决了，现在只要解决递归调用了。

```c
MERGE_SORT(array, start, end) {
	 if start < end:
	 		then   mid = ⌊(end - start) / 2⌋   //1. 将 n 个 元素 分割 成含有 n / 2个元素的子序列
	 		MERGE_SORT(array, start, mid)      //2. 用归并排序法对左子序列递归的排序
	 		MERGE_SORT(array, mid + 1, end)    //2. 用归并排序法对右子序列递归的排序
	 		merge(array, start, mid, end)     //3. 合并两个已排序的子序列得到排序的结果
}
```

对于递归调用我们必须有一个结束递归的条件，否则就会一直调用下去不会结束。上面的start < end 就是结束递归的条件， 对应的情况就是上面图中最后一层只有一个元素的序列。

打完收工。



